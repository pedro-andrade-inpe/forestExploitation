import("gis")

local distributions = {
    Random{mean = 4.36559088, sd = 2.236812764},
    Random{mean = 4.10921335, sd = 2.545055233},
    Random{mean = 4.54891340, sd = 2.700811366},
    Random{mean = 3.92202091, sd = 2.600028208},
    Random{mean = 4.03452301, sd = 2.499570965},
    Random{mean = 3.82624554, sd = 2.490403261},
    Random{mean = 3.46419415, sd = 2.490027159},
    Random{mean = 4.00906252, sd = 2.541591693},
    Random{mean = 3.59394901, sd = 13.01854167}
}

local ADI = {  -- annual diametric increment
    -- CLASS    1     2     3     4     5     6     7     8     9
    braz     = {.291, .317, .442, .473, .623, .587, .587, .717, .836}, -- 2017
    borges   = {.287, .325, .437, .452, .470, .478, .531, .417, .000},
    canneti  = {.283, .377, .451, .475, .485, .493, .569, .580, .546},
    oliveira = {.427, .606, .720, .805, .710, .751, .903, .816, .838},
    mean     = {.290, .413, .451, .551, .617, .598, .658, .684, .712},
}

-- return the class of a tree given its diameter
function getClass(diameter)
    return math.floor(diameter / 1000) + 1
end

ForestExploitation = Model{
    cut_cycle = 30, -- years (cut, collateral damage)
    ypl = 10, -- years (birth, growth, mortality)
    mcd = 6, -- minimum cut diameter (class number)
    damage_exp = 0.13, -- 13%
    cut_vol = 3.334, -- m3
    reman_vol = 0.9822, -- m3
    seeds_vol = 1.7466, -- m3
    max_vol = 30, -- m3/ha
    old_mortality = 0.009, -- % year-1 according to Aleixo et al (2018)
    shapefile = Mandatory("File"),
    finalTime = 90,
    adi = Choice{
        medium    = ADI.mean,
        braz      = ADI.braz,
        borges    = ADI.borges,
        canneti   = ADI.canneti,
        oliveira  = ADI.oliveira,
        default = "braz"
    },
    bir_dth = Choice{
        colpini     = {birth = 0.3,  death = 0.78}, -- -0.48
        andrade_t1  = {birth = 2.51, death = 1.7},  -- +0.81
        higuchi     = {birth = 0.7,  death = 0.7},  --  0.00
        rocha       = {birth = 0.9,  death = 0},    -- +0.04
        souza       = {birth = 1.9,  death = 1.13}, -- +0.77
        oliveira_t0 = {birth = 1,    death = 1.2},  -- +0.20
        oliveira_t1 = {birth = 2,    death = 2},    --  0.00 PMFS
        oliveira_t3 = {birth = 3.5,  death = 2.5},  -- +1.00 PMFS
        gouveia_t1  = {birth = 3.3,  death = 2.6},  -- +0.70 PMFS
        gouveia_t2  = {birth = 3.78, death = 2.94}, -- +0.84 PMFS
        gouveia     = {birth = 3.54, death = 2.77}, -- +0.77 SELECTED
        oliveira_16 = {birth = 4.57, death = 3.62}, -- +0.95 PMFS
        default = "gouveia"
    },
    -- TODO: esta funcao deveria considerar a area que esta sendo explorada
    -- TODO: esta funcao nao esta sendo usada. onde ela deveria aparecer?
    get_hectare = function(model)
        return model.cs.cells[1]:area() / 1e4
    end,
    max_exp = function(model)
        return model.max_vol / model.cut_vol
    end,
    adi_rate = function(model, class)
        return model.adi[class]
    end,
    bir_rate = function(model)
        return model.bir_dth.birth
    end,
    dth_rate = function(model, age) -- "young" or "old"
        if age == "young" then
            return model.bir_dth.death
        else -- "old"
            return model.old_mortality
        end
    end,
    save_state = function(model, time, name)
        local attrs = {}
        --local exts = {}
        for i = 1, 9 do
            attrs[i] = "CLASS"..i.."_SUM"

            forEachCell(model.cs, function(cell)
                cell["CLASS"..i.."_SUM"] = cell:get_trees(i)
            end)

            attrs[i + 9] = "EXTRACTED"..i.."_SUM"
        end

       -- model.cs:save(params.adi.default.."time_"..time.."_"..name, attrs)
        --model.cs:save(params.adi.default.."time-extracted_"..time.."_"..name, exts)
        local values = time.."-"..name.."\t"
        for i = 1, 9 do
            values = values..math.floor(model.cs["CLASS"..i.."_SUM"](model.cs), 0).."\t"
            --values = values..round(model.cs["EXTRACTED"..i.."_SUM"](model.cs), 0).."\t"
        end

        print(values)
    end,
    init = function(model)
        model.cell = Cell{
            EXTRACTED1_SUM = 0,
            EXTRACTED2_SUM = 0,
            EXTRACTED3_SUM = 0,
            EXTRACTED4_SUM = 0,
            EXTRACTED5_SUM = 0,
            EXTRACTED6_SUM = 0,
            EXTRACTED7_SUM = 0,
            EXTRACTED8_SUM = 0,
            EXTRACTED9_SUM = 0,
            -- total amount of trees belonging to classes 1 to 9
            total_trees = function(cell)
                local total = 0

                forEachElement(cell.trees, function(_, quantity)
                    total = total + quantity
                end)

                return total
            end,
            -- return the number of trees in a given class
            get_trees = function(cell, class)
                local total = 0

                local min = (class - 1) * 1000
                local max = class * 1000
                forEachElement(cell.trees, function(size, quantity)
                    if size >= min and size < max then
                        total = total + quantity
                    end
                end)

                return total
            end,
            add_trees = function(cell, class, quantity)
                local random = distributions[class]

                local min = 0
                local max = 1000

                if class == 1 then -- class 0: [1, 999]. class 1: [1000, 1999], ...
                    min = 1
                end

                for i = 1, quantity do
                    local value = -1

                    while value < min or value >= max do
                        value = math.floor(random:sample() * 100)
                    end

                    local diameter = (class - 1) * 1000 + value

                    if not cell.trees[diameter] then cell.trees[diameter] = 0 end

                    cell.trees[diameter] = cell.trees[diameter] + 1
                end
            end,
            minit = function(cell)
                cell.trees = {}

                for class = 1, 9 do
                    local mclass = "CLASS"..class.."_SUM"
                    local quantity = cell[mclass]
                    -- H0: O MODELO REPRESENTA DIAMETROS COM DUAS CASAS DECIMAIS.
                    -- COMO AS MEDIDAS SAO EM CM OS VALORES SAO MULTIPLICADOS POR 100
                    -- PARA PODER TRABALHAR COM NUMEROS INTEIROS

                    -- H1: TODAS AS ARVORES COMECAM A SIMULACAO NO MEIO DA CLASSE:
                    -- 5CM PARA CLASSE 1, 15CM PARA CLASSE 2, ETC.
                    cell:add_trees(class, quantity)
                end

                cell.max_trees = cell:total_trees()
            end,
            remove_trees = function(cell, class, amount)
                amount = math.floor(amount)

                local candidates = {}
                local total = 0

                forEachElement(cell.trees, function(size)
                    local mclass = getClass(size)

                    if mclass == class then
                        table.insert(candidates, size)
                        total = total + size
                    end
                end)

                local random = Random{min = 1, max = #candidates, step = 1}
                local must_remove = amount

                while must_remove > 0 do
                    local position = candidates[random:sample()]
                    local to_be_removed = math.ceil(cell.trees[position] / total * amount)

                    if to_be_removed > must_remove then
                        to_be_removed = must_remove
                    end

                    cell.trees[position] = cell.trees[position] - to_be_removed
                    must_remove = must_remove - to_be_removed
                end

                local extracted = "EXTRACTED"..class.."_SUM"
                cell[extracted] = cell[extracted] + amount
            end,
            -- return the amount of trees from class mct to class 9
            sum_mcd_9 = function(cell)
                local sum = 0

                for i = model.mcd, 9 do
                   sum = sum + cell:get_trees(i)
                end

                return sum
            end,
            usable_volume = function(cell)
                return cell:cut_trees() * 3.334 + cell:remaining() * 0.9822 + cell:seeds() * 1.7466
            end,
            cut_trees = function(cell)
                return cell:sum_mcd_9() * 0.8048
            end,
            remaining = function(cell)
                return cell:sum_mcd_9() * 0.1
            end,
            proh_cut = function(cell)
                return cell:sum_mcd_9() * 0.0045
            end,
            non_commer = function(cell)
                return cell:sum_mcd_9() * 0.039
            end,
            -- compute the number of seed trees
            -- TODO: onde essa funcao deveria ser usada?
            seeds = function(cell)
                return cell:sum_mcd_9() * 0.1517
            end,
            -- executes trees growth
            growth = function(cell)
                local new_trees = {}

                forEachElement(cell.trees, function(size, quantity)
                    local class = getClass(size)

                    -- H2: TODAS AS ARVORES DE UM MESMO DIAMETRO CRESCEM DA MESMA FORMA,
                    -- POR ISTO TRABALHAMOS COM QUANTIDADES DE ARVORES COM UM MESMO DIAMETRO
                    -- EFEITO COLATERAL: CLASSES DIAMETRICAS PODEM FICAR SEM ARVORES DURANTE
                    -- A SIMULACAO
                    local new_size = size + math.floor(model:adi_rate(class) * 100 * model.ypl)

                    if new_size > 8500 then new_size = 8500 end -- trees have a maximum diameter of 85cm

                    if new_trees[new_size] then
                        new_trees[new_size] = new_trees[new_size] + quantity
                    else
                        new_trees[new_size] = quantity
                    end
                end)

                cell.trees = new_trees
            end,
            -- creates new trees in the class 1 by birth
            birth = function(cell)
                local rate = (1 + model:bir_rate() / 100) ^ model.ypl
                local quantity = math.floor(cell:total_trees() * (rate - 1))

                local max_birth = cell.max_trees - cell:total_trees()

                if quantity > max_birth then quantity = max_birth end

                cell:add_trees(1, quantity)
            end,
            -- exploit the cell, cutting trees from class 9 to mcd
            exploitation = function(cell)
                local reserved = {0, 0, 0, 0, 0, 0, 0, 0, 0}
                local remaining = cell:remaining()
                local sum_mcd_9 = cell:sum_mcd_9()

                if remaining < sum_mcd_9 * 0.1  then
                    local new_remaining = sum_mcd_9 * 0.1 - remaining
                    local i = model.mcd

                    while new_remaining > 0 do
                        local trees_i = cell:get_trees(i)

                        if new_remaining > trees_i then
                            reserved[i] = trees_i
                            new_remaining = new_remaining - trees_i
                        else
                            reserved[i] = new_remaining
                            new_remaining = 0
                        end
                    end
                end

                local legal_limit = 2500.0 * 30
                local limit = legal_limit
                --local limit = math.min(cell:usable_volume(),legal_limit)

                for i = 9, model.mcd, -1 do
                    local trees_i = cell:get_trees(i)
                    limit = limit - (trees_i - reserved[i]) * (1 - 0.8048) * 3.334
                    if limit <= 0 then
                        local remove = (trees_i - reserved[i]) * 0.8048 * 0.6 - (limit / 3.334)

                        cell:remove_trees(i, remove)
                        break
                    end

                    local remove = (trees_i - reserved[i]) * 0.8048 * 0.6
                    cell:remove_trees(i, remove)
                end
            end,
            -- collateral damage by exploitation
            collateral_damage = function(cell)
                for i = 1, 4 do
                    -- TODO: talvez esta estrategia nao seja boa, ver com o time
                    local damaged = cell:get_trees(i) * model.damage_exp
                    cell:remove_trees(i, damaged)
                end
            end,
            -- natural mortality of young trees
            natural_mortality_young = function(cell)
                local rate = (1 - model:dth_rate("young") / 100) ^ model.ypl

                for i = 1, 5 do
                    local trees = cell:get_trees(i)
                    cell:remove_trees(i, trees * (1 - rate))
                end
            end,
            -- natural mortality of old trees
            natural_mortality_old = function(cell)
                local rate = (1 - model:dth_rate("old") / 100) ^ model.ypl

                for i = 6, 9 do
                    local trees = cell:get_trees(i)

                    cell:remove_trees(i, trees * (1 - rate))
                end
            end
        }
        params = ForestExploitation:getParameters()
        local outputDir = Directory(os.date(params.adi.default.."-%y-%m-%d-simulation-"..model.finalTime.."-%Hh%M"))

        outputDir:create()
        model.shapefile:copy(outputDir)
        sessionInfo().currentFile:copy(outputDir)

        model.project = Project{
            file = outputDir.."/results.qgs",
            clean = true
        }

        model.layer = Layer{
            project = model.project,
            file = outputDir.."/"..model.shapefile:name(),
            name = "input"
        }

        print("Creating cells")
        model.cs = CellularSpace{
            layer = model.layer,
            instance = model.cell
        }

        cells = {}

        for i = 1, 2 do -- 30 do
           table.insert(cells, model.cs.cells[i])
        end

 --       model.cs.cells = cells

        model.cs:minit()

        print("Running simulation")

        model.df = DataFrame{
            class1 = {model.cs:CLASS1_SUM()},
            class2 = {model.cs:CLASS2_SUM()},
            class3 = {model.cs:CLASS3_SUM()},
            class4 = {model.cs:CLASS4_SUM()},
            class5 = {model.cs:CLASS5_SUM()},
            class6 = {model.cs:CLASS6_SUM()},
            class7 = {model.cs:CLASS7_SUM()},
            class8 = {model.cs:CLASS8_SUM()},
            class9 = {model.cs:CLASS9_SUM()},
            extraced1 = {model.cs:EXTRACTED1_SUM()},
            extraced2 = {model.cs:EXTRACTED2_SUM()},
            extraced3 = {model.cs:EXTRACTED3_SUM()},
            extraced4 = {model.cs:EXTRACTED4_SUM()},
            extraced5 = {model.cs:EXTRACTED5_SUM()},
            extraced6 = {model.cs:EXTRACTED6_SUM()},
            extraced7 = {model.cs:EXTRACTED7_SUM()},
            extraced8 = {model.cs:EXTRACTED8_SUM()},
            extraced9 = {model.cs:EXTRACTED9_SUM()},
        }

        --[[cuts = DataFrame{
            before = {},
            cut = {},
            after = {},
            vol_cut = {}
        }]]--

        model.cells = #model.cs

        model:save_state(0, "0_begin")

        model.timer = Timer{
            Event{start = 0, priority = "high", period = model.cut_cycle, action = function(ev)
                model.cs:collateral_damage()
                model:save_state(ev:getTime(), "1_coll_damg")

                model.cs:exploitation()
                model:save_state(ev:getTime(), "2_exploit")
            end},
            Event{start = model.ypl, priority = "low", period = model.ypl, action = function(ev)
                model.cs:natural_mortality_young()
                model:save_state(ev:getTime(), "3_mort_young")

                model.cs:natural_mortality_old()
                model:save_state(ev:getTime(), "4_mort_old")

                model.cs:growth()
                model:save_state(ev:getTime(), "5_growth")
                model.cs:birth()

                model:save_state(ev:getTime(), "6_birth")
                model.df:save("test"..ev:getTime()..".csv")
            end}
        }
    end
}

